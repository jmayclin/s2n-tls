/* automatically generated by rust-bindgen 0.65.1 */


// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0


#![allow(unused_imports, non_camel_case_types)]

use libc::{iovec, FILE, off_t};
// specify that aws-lc-rs is used, so that the rust compiler will link in the appropriate
// libcrypto artifact.
#[cfg(not(s2n_tls_external_build))]
extern crate aws_lc_rs as _;

use crate::api::*;


extern "C" {
    #[doc = " Enables sending using kTLS on a given connection.\n\n See above for the limitations on when kTLS can be enabled. Additionally,\n s2n_connection_ktls_enable_send must be called after the handshake completes\n but before the handshake is freed with s2n_connection_free_handshake.\n It may be called after some application data is sent and received without kTLS,\n but there must be no pending application data that requires flushing. If these\n requirements are not met, enabling kTLS will fail with an error.\n\n After kTLS is enabled for sending, s2n_send, s2n_sendv, and s2n_sendv_with_offset\n will use kTLS. kTLS should result in memory and CPU savings. s2n_sendfile will\n also become available.\n\n For applications using kTLS to avoid copying or allocating memory, s2n_sendv\n should be preferred over s2n_sendv_with_offset. For s2n_sendv_with_offset,\n s2n-tls may need to copy the provided iovec array to apply the offset, and may\n need to allocate memory to copy large (>16) iovec arrays.\n\n If kTLS is enabled for sending, s2n_connection_get_wire_bytes_out will always\n return 0 instead of an accurate count.\n\n @warning Due to the uncertainty around kTLS support, the signature of this\n method is likely to change before kTLS is marked as stable.\n\n @param conn A pointer to the connection.\n @returns S2N_SUCCESS if kTLS is successfully enabled. If kTlS is not successfully\n enabled, returns S2N_FAILURE but the connection may proceed without kTLS."]
    pub fn s2n_connection_ktls_enable_send(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Enables receiving using kTLS on a given connection.\n\n See above for the limitations on when kTLS can be enabled. Additionally,\n s2n_connection_ktls_enable_recv must be called after the handshake completes\n but before the handshake is freed with s2n_connection_free_handshake.\n It may be called after some application data is sent and received without kTLS,\n but there must be no buffered application data that requires draining. If these\n requirements are not met, enabling kTLS will fail with an error.\n\n After kTLS is enabled for receiving, s2n_recv will use kTLS. This may result\n in memory and CPU savings, but currently will still buffer and copy application data.\n We will further optimize s2n_recv for kTLS in the future.\n\n If kTLS is enabled for receiving, s2n_connection_get_wire_bytes_in will always\n return 0 instead of an accurate count.\n\n @warning Due to the uncertainty around kTLS support, the signature of this\n method is likely to change before kTLS is marked as stable.\n\n @param conn A pointer to the connection.\n @returns S2N_SUCCESS if kTLS is successfully enabled. If kTlS is not successfully\n enabled, returns S2N_FAILURE but the connection may proceed without kTLS."]
    pub fn s2n_connection_ktls_enable_recv(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Allows kTLS to be enabled if a connection negotiates TLS1.3.\n\n Enabling TLS1.3 with this method is considered \"unsafe\" because the kernel\n currently doesn't support updating encryption keys, which is required in TLS1.3.\n s2n_connection_get_key_update_counts can be used to gather metrics on whether\n key updates are occurring on your connections before enabling TLS1.3.\n\n In order to safely enable TLS1.3, an application must ensure that its peer will\n not send any KeyUpdate messages. If s2n-tls receives a KeyUpdate message while\n kTLS is enabled, it will report an S2N_ERR_KTLS_KEYUPDATE S2N_ERR_T_PROTO error.\n\n Additionally, an application must not use kTLS to attempt to send more than 35GB\n of data and must not call s2n_send more than 23 million times. If either of these\n limits is exceeded, it will report an S2N_ERR_KTLS_KEY_LIMIT S2N_ERR_T_PROTO error.\n\n This method must be called before enabling kTLS on a connection using\n s2n_connection_ktls_enable_send or s2n_connection_ktls_enable_recv.\n\n @param config A pointer to the config.\n @returns S2N_SUCCESS if successfully enabled, S2N_FAILURE otherwise."]
    pub fn s2n_config_ktls_enable_unsafe_tls13(config: *mut s2n_config) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Reports the number of times sending and receiving keys have been updated.\n\n This only applies to TLS1.3. Earlier versions do not support key updates.\n\n @warning s2n-tls only tracks up to UINT8_MAX (255) key updates. If this method\n reports 255 updates, then more than 255 updates may have occurred.\n\n @param conn A pointer to the connection.\n @param send_key_updates Number of times the sending key was updated.\n @param recv_key_updates Number of times the receiving key was updated.\n @returns S2N_SUCCESS if successful, S2N_FAILURE otherwise."]
    pub fn s2n_connection_get_key_update_counts(
        conn: *mut s2n_connection,
        send_key_updates: *mut u8,
        recv_key_updates: *mut u8,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Sends the contents of a file as application data.\n\n s2n_sendfile should be more efficient than s2n_send because the copy between\n the file and the write socket happens inside the kernel.\n\n This method is only supported if kTLS is enabled for sending.\n\n @note For a TLS1.3 connection, the `count` argument will be used to enforce\n safe sending limits regardless of the actual size of the file. Applications\n should not set `count` excessively high.\n\n @param conn A pointer to the connection.\n @param fd The file descriptor to read from. It must be opened for reading and\n support mmap-like operations (i.e., it cannot be a socket).\n @param offset The offset in the file to begin reading at.\n @param count The maximum number of bytes to read from the file.\n @param bytes_written Will be set to the number of bytes written if successful.\n @param blocked Will be set to the blocked status if an `S2N_ERR_T_BLOCKED` error is returned.\n @returns S2N_SUCCESS if any bytes are successfully written, S2N_FAILURE otherwise."]
    pub fn s2n_sendfile(
        conn: *mut s2n_connection,
        fd: ::libc::c_int,
        offset: off_t,
        count: usize,
        bytes_written: *mut usize,
        blocked: *mut s2n_blocked_status::Type,
    ) -> ::libc::c_int;
}
